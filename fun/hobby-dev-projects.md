# hobby projects

## potential projects

### learning platform

* dictionary
* exercices
  * [temamemo](https://github.com/morarupasukaru/temamemo) / flashcards
  * [dico](https://github.com/morarupasukaru/dico)
  * *kikitori*: flashcard educational application to practise listening comprehension
  * exercice templates
* encyclopedia / articles
  * word to ascii docs (for upload)
  * github interface to download articles written in markdown or ascii-doc
* glossary
* stats / progress
* learn-mode
* editor-mode / teacher
* cyclus / topics / years
* education curriculum
  * subject areas
  * cross capabilities
  * general education 
* (notes)

## search docs application

### main goals
* provide a term search into json objects
* filter search by attribute like tags
* json objects can have dynamic properties, e.g. tags as array of string

### versions
* "terminal-first" application version (could be implemented in fantasy console)
* angular mobile-first application
  * result as tables, cards, (tree)

### features
* prio 1 - term query
* prio 1 - result of query in short form
* prio 1 - detail of single result can be displayed
* prio 2-  short form / template (displayed attributes and stringify) customizable
* prio 2 - detail form / template (displayed attributes and stringify) customizable
* prio 2 - tags filtering
* prio 3 - tags editing
* prio 3 - define detail of entry

### use cases
* search words (german) in a directory (with translations)
* search kanji by levels
* search into markdown documents (offline wiki)

### implicit acceptance criterias
* code auto-formating/prettier
* linting
* git hook for commit message
* integration-tests for API (SpringDoc?)
* frontend-tests for frontend (playwright? embedded prototype/demo?)
* automatic upgrade lib version (like renovate)

## micro-frontend
* frontend deployed in github or CDN; url of backend can be specified as url argument (security?)
* SpringBoot backend
* Angular frontend
* REST API with OpenAPI 3 (spec-first)
* Angular Material for UI-design
* E2E tests with (with cypress, selenium or suggested framework by Angular Team)
* mobile-first UI design
* storage TBD (db, nosql, files?)
* full-text search
  * search done in UI to provide offline
    * search with an index or by scanning whole dictionaries? PWA
* logging with SL4J  (add custom MDC parameter, e.g. flow-id)
* monitoring with Spring Actuator (which endpoints?)
* Swagger-UI (or alternative)
* no technical id in url
* ULID instead of UUID if needed

## Dictonnary editor

specifications of a SPA application to edit dictonnary.

Project was initialy planed for https://github.com/morarupasukaru/webstack-blueprint.

Project require lot of works and therefore was is currently archived

## features

* CRUD frontend (read/write role, write access to all dictionaries)
  * publish new major version of a dictionary
* online/offline search (read role) on single/multiple dictionaries
  * single text search
  * all/only favorites
* admin to grant/revoke write access (admin role)
* homepage (public, depend of un/authentified state)
* devops API (swagger-ui, devops role)
* TODO login where?

## entities

* _dictionary_
  * _id_ : uuid
  * _title_ : i18n string
  * _description_: i18n string
  * _entry_
    * _id_ : uuid
    * _value_ : string
    * _search_token_ : string[] -> generated by backend, static
    * _sort?_
  * _release_
    * _version_ : x.y (entry change +1 minor, major changes on user actions)
    * _dictionnary_ : release data
    * _description_ : string
* _user_
  * _user_profile_
    * _language_ (of ui)
    * _dictionaries_
      * _saved_offline_version_?: string
      * _favorites_: uuid[] (clean-up on new download, search after favorites)
      * _language_?: string (of dictionnary if i18n string have several language)
* i18n string:
  *
  [language iso]: string
* language iso: 2 char code

## screens

* public _homepage_ (if unlogged)
  * teaser of available features, dictionnaries
* _login/register_ screen
* _dictionnaries_ screen displayed after login:
  * list of available dictionary (with indication if offline available or not)
    * click on dictionary --> open search
    * button to edit dictionnary --> open dictionnary screen
    * button to create dictionnary --> open dictionnary screen
    * button to save dictionnary offline (toggle)
    * short overview of dictionnary (as markdown?)
* _dictionnary_ screen (view/edit/create modes)
  * delete button --> if RW access
  * edit button --> if RW access (require confirmation)
    * 'title, description' attributes are editable with save/cancel button
  * search button
  * offline capability
    * save offline (toggle)
    * delete offline version
    * update offline version (if new version available)
  * button to edit entries --> navigate to _entries search_ screen
  * releases screen --> if RW access
* _dictionnary releases_
  * list available releases
  * publish new release
    * release name, description, version, date
* _entries search_ screen
  * search based on single text and with multiple choices of directory and favorite only/all 
  * click on entry --> navigate to _entry_ screen
  * new button --> if RW access and only one dictonnary is selected in search filter
  * delete button --> if RW access
  * favorite toggle on/off
  * short overview of entry (as markdown?)
* _entry_ screen (view/edit/create modes)
  * delete button --> if RW access
  * edit attribute --> if RW access
  * favorite toggle on/off
* _access_rights_ screen
  * list users
  * allow to change roles (admin set rw/admin roles, devops set rw/admin/devops roles) 
* _devops_ screen --> or/and swagger-ui
  * TODO ?
* misc
  * display if offline
  * display/set language
  * link to github
  * display if access-right (rw, devops, search only)
  * navigation bar
  * notifications when new version of saved offline dictionaries are available (not too many)

## Dico

Primary goal of *dico* is to provide full-text search in *dictionnaries*.

Secondary goal of *dico* is to be integrated as a micro-frontend application into a study workbench solution to ease
study in one or several topics.

### Use cases

* user can perform full-text search in one selected dictonnary
* user can infinite-scroll in found entries
* user can mark/unmark found entry as favorite entry
* user can decide to search only in favorite entries or all entries
* user can decide which dictionnary to search in
* user can see text matching search terms in found entries (e.g. higlighted)
* user should see the whole entries if possible (or provide collapse/expand feature for big entry)
* out of scope
  * authentification -> will be done in the workbench / shell
  * authorization to retrict available dictionnaries (logged user can search in all available dictionnaries)
  * user/account registration
  * user/account deletion
  * edition of dictionary data (e.g. add/delete/update entries)
  * language selection (language of the browser taken)
  * display total of found entries -> infinite scrolling instead of pagination

### Non-functional requirements

* mobile-first / responsive-design: display more entries on higher resolutions (e.g. more columns like a physical
  dictionnary)
* i18n: language of the application is the default language of the browser
* accessibilty
* pwa / offline capability
* provide a nice favicon, pwa desktop icon, etc. (copyright free)
* deployment: executable jar without initial dictionnary / data
* data / dictionnary can be uploaded through REST API (protected with basic auth)
  * uploaded data are validated
* generic layout for dictionnary entry (fields are pro dictionnary different)
* generic fulltext-search
* [full-text search](https://en.wikipedia.org/wiki/Full-text_search) requirements
  * search done in a small size dictionnary (e.g. 100000 entries)
  * offline search
  * word search
  * "starts with" search per default applied
  * "exact match" search possible by delimiting seached text with quotation marks, e.g. "text"
  * no minimal number of characters to start the search
  * non-letters are replaced as whitespace (text are trimed & multiple whitespaces are replaced with single whitespace)
  * search done in lowercase
  * support accent synonyms (é=e, ä=ae=a)
  * found entries sorted with a predefined order (part of dictionnary entry field)
  * search done in a flattened field matching)
* dictionary in a OpenAPI format with following data:
  * id: should remain unchanged in future versions of the dictionnary
  * name in all supported languages
  * description in all supported languages (optional)
  * version (with semantic versioning: major.minor.patch)
  * topic
    * id: should remain unchanged in future versions of the dictionnary
    * name in all supported languages
    * description in all supported languages (optional)
  * entries
    * id: should remain unchanged in future versions of the dictionnary (required for user's favorites)
    * visual: string as domain-specific language used for layout of entry (markdown or ascii-doc oriented) --> try logic
      validate this value (regexp?)
    * detail; array of:
      * mediaqueryName
      * value: entry as multiple lines representation used for detail
    * search: string -> flattened field of searchable fields
    * sort: number
  * metadata
    * accent synonyms: array of pair of string; e.g. [["e", "é"], ["a", "ä", "ae"]] (required in ui to highlight text in
      found entries)
* out of scope
  * REST endpoint for upload dictionnary should be authorized for user with "admin"
  * authorization with two roles: user, admin
  * support of dictionary with *a lot of entries*
  * generation of input *dico* "dictionnary data" based on some conventional structured db of dictionnary entries
  * no bidirectional dictionnary support; a bi-directional dictionnary has to be split in two dictionnaries (e.g. "
    french to english" and "english to french")
  * no phrase search
  * no [wildcard](https://en.wikipedia.org/wiki/Wildcard_character)
  * no [stop words](https://en.wikipedia.org/wiki/Stop_word)
  * no [stemming](https://en.wikipedia.org/wiki/Stemming) (otherwise word stem / root must be provided as search field
    in dictionary data)
  * no boolean queries
  * no [phrase search](https://en.wikipedia.org/wiki/Phrase_search)
  * no [regular expression](https://en.wikipedia.org/wiki/Regular_expression)
  * no [fuzzy search](https://en.wikipedia.org/wiki/Fuzzy_search)
  * no search in multiple dictionnaries
    
## utopian projects
utopian projects are projects cool to develop but require lot of times and certainly won't be made but who knows...

* digital instrument [angular] (see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Simple_synth]
* cleopatra like / admin [springboot + angular + angular material + ...]
* document search API with authorization based on data entries [springboot]
  * de: https://github.com/hdaSprachtechnologie/odenet
* digital instrument [angular] (see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Simple_synth, https://github.com/deanmalone/PianoPlay/)
* cleopatra like / admin [springboot + angular + angular material + ...]
* [learning platform](./learning-platform.md) web application as micro-frontends with shell
* dungeon crawler like dungeon master in browser
  * https://excaliburjs.com/
  * http://dmweb.free.fr/
* dungeon crawler / maze editor
  * https://github.com/changhuixu/angular-maze
* rogue game like angband or dungeon crawl stone soup
  * https://github.com/justindujardin/angular-rpg
  * https://github.com/tome2/tome2
  * https://rephial.org/
  * https://crawl.develz.org/
  * https://github.com/crawl/crawl

_(last update 27.09.2025)_

[*Go to parent page*](../README.md)

